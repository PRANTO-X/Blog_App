const blogs = [
  {
    id: 1,
    title: "Getting Started with React",
    content: "React is a popular JavaScript library developed by Facebook for building user interfaces, especially single-page applications where you need a fast and interactive experience. It allows developers to create large web applications that can change data, without reloading the page. React is all about components. A component is a reusable piece of UI that can manage its own state and logic. The power of React comes from its declarative syntax, virtual DOM, and component-based architecture. To get started with React, you first need to install Node.js and a code editor like VS Code. Then, you can use Create React App, a toolchain that sets up a modern web app by running one command. Once you have your app running, you’ll typically work with JSX, a syntax extension that allows you to write HTML elements in JavaScript. JSX makes it easier to write and add HTML in React. Understanding props and state is also fundamental. Props allow data to be passed from one component to another, while state is managed within the component and determines its behavior and rendering. React also introduces the concept of hooks like useState and useEffect, which simplify state and lifecycle management in function components. Once you understand the basics, you can dive deeper into advanced topics like context API, React Router for navigation, and performance optimization techniques. React is widely adopted in the industry and has a huge ecosystem of libraries and tools. Whether you're building a personal blog, a business dashboard, or a full-scale web application, React provides a flexible and scalable solution for modern front-end development.",
    author: "John Doe",
    img: "https://images.unsplash.com/photo-1632887741842-6d2d906b8979",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 2,
    title: "Understanding JavaScript Closures",
    content: "JavaScript closures are a powerful concept that every developer should understand to write efficient and optimized code. A closure is created when a function is defined inside another function, and the inner function has access to the outer function's variables. This concept allows functions to have 'private' variables, which are not accessible from outside. Closures are useful in many situations, such as data hiding, function currying, and creating factory functions. One classic example is a counter function. If you define a function that returns another function and maintains a count variable inside the outer function, each call to the returned function will retain the count value. This retained access to the variable even after the outer function has finished executing is what defines a closure. Understanding closures is critical when working with asynchronous code and callbacks, especially in loops. In the past, JavaScript developers faced issues when using `var` inside loops due to closure behavior, which was later addressed by using `let` in ES6. Closures can also help avoid polluting the global namespace and encapsulate functionality. Many libraries and frameworks, including jQuery and React, make use of closures behind the scenes. When debugging code that involves closures, developers must remember that functions can retain access to the scope in which they were defined, not the scope in which they were executed. This behavior can be confusing at first but is a core part of JavaScript’s design. Overall, closures provide a powerful tool for abstraction, encapsulation, and modular code organization.",
    author: "Alice Smith",
    img: "https://images.unsplash.com/photo-1509967419447-84b23cb1cd79",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 3,
    title: "CSS Flexbox: A Complete Guide",
    content: "CSS Flexbox is a layout model that makes it easier to design flexible responsive layout structures without using floats or positioning. Flexbox allows items in a container to automatically adjust their size and position based on the available space. This is particularly useful for building web pages that work across different screen sizes. Flexbox works by applying the `display: flex` property to a container element. The children of that container then become flex items that follow a set of flexible layout rules. Some of the key properties of a flex container include `flex-direction`, which controls the direction of items (row or column), and `justify-content`, which aligns items horizontally. Other useful properties are `align-items`, `align-content`, and `flex-wrap`, which handle vertical alignment and multi-line wrapping. On the flex items themselves, you can use properties like `flex-grow`, `flex-shrink`, and `flex-basis` to control how they scale. The shorthand property `flex` is often used to define grow, shrink, and basis in one line. One of the best parts about Flexbox is its ability to handle both horizontal and vertical centering, which used to be notoriously difficult in CSS. Flexbox has broad browser support and is used widely in modern web development. It is ideal for components like navbars, cards, grids, and any UI layout where element alignment matters. While CSS Grid is more powerful for 2D layouts, Flexbox excels in 1D scenarios. Developers often use both in tandem for maximum flexibility. Learning Flexbox is a must for anyone working with frontend design.",
    author: "Michael Ray",
    img: "https://images.unsplash.com/photo-1461749280684-dccba630e2f6",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 4,
    title: "Demystifying the Virtual DOM",
    content: "The Virtual DOM is a key concept in libraries like React that improves performance and user experience by minimizing direct manipulation of the real DOM. In traditional web applications, frequent DOM updates can be expensive and lead to slow rendering, especially in complex UI structures. The Virtual DOM solves this by acting as an in-memory representation of the real DOM. When the state of an application changes, a new virtual DOM tree is created and compared with the previous one. This process is called 'diffing'. The differences are then calculated, and only the necessary updates are applied to the real DOM in a process known as 'reconciliation'. This leads to much more efficient rendering. The Virtual DOM abstracts the direct DOM manipulation away from the developer, allowing them to focus on the application logic and UI structure. React’s `render()` function always returns a new Virtual DOM tree, and React takes care of optimizing what really changes. Understanding the Virtual DOM helps in optimizing components using tools like `shouldComponentUpdate`, `React.memo`, and `useMemo`. These techniques prevent unnecessary re-renders and boost performance. Developers can also explore React's developer tools to visualize the Virtual DOM changes and component updates. While the Virtual DOM is a React-specific implementation, similar ideas exist in other libraries like Vue.js and Inferno. It’s important to note that the Virtual DOM is not faster than the real DOM in all cases, but its selective update strategy provides performance benefits in most real-world applications.",
    author: "Emily Carter",
    img: "https://images.unsplash.com/photo-1498050108023-c5249f4df085",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 5,
    title: "Mastering Git and GitHub",
    content: "Git is a distributed version control system that allows developers to track changes in their codebase, collaborate with others, and manage different versions of a project. GitHub is a platform built around Git that adds features like repositories, pull requests, issues, and collaboration tools. Understanding Git commands like `git init`, `git clone`, `git add`, `git commit`, and `git push` is fundamental for any developer. Branching in Git allows multiple developers to work on different features simultaneously. Using `git branch`, `git checkout`, and `git merge`, you can create and combine branches effectively. A good Git workflow involves creating a new branch for each feature or bug fix, making commits with clear messages, and opening pull requests for code review. GitHub facilitates this workflow with its web-based interface and integrations. It also supports GitHub Actions for CI/CD automation, GitHub Pages for static hosting, and integrations with project management tools like Jira and Trello. Understanding `.gitignore`, resolving merge conflicts, and using rebase are more advanced Git concepts that improve team productivity. You can also manage open-source contributions and collaborate globally through forks and issues. Mastering Git and GitHub is essential for working on any team-based or long-term software project. It provides safety, accountability, and control over your code changes.",
    author: "Sophia Nguyen",
    img: "https://images.unsplash.com/photo-1516321318423-5b6b3395c33a",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 6,
    title: "Building Responsive Layouts with Tailwind CSS",
    content: "Tailwind CSS is a utility-first CSS framework that allows you to rapidly build custom designs directly in your HTML. Unlike traditional CSS frameworks like Bootstrap, Tailwind doesn’t come with pre-styled components. Instead, it provides utility classes that you combine to build your own unique UI. Tailwind excels at creating responsive designs. It uses mobile-first breakpoints like `sm`, `md`, `lg`, and `xl` that can be applied to any utility class. For example, `text-sm md:text-lg` makes text small on mobile but larger on medium screens. Flexbox and Grid are both supported out of the box. You can use `flex`, `grid`, `justify-between`, `items-center`, and `gap-4` to layout content easily. Tailwind also includes spacing, color, typography, animation, and dark mode utilities. You can extend Tailwind through the `tailwind.config.js` file to add custom themes, breakpoints, and plugins. The JIT (Just-In-Time) compiler introduced in Tailwind v2.1 makes development even faster by generating styles on demand. Tailwind CSS is loved by developers because it keeps the styling close to the markup and encourages consistency. When used correctly, it helps build responsive and beautiful user interfaces without writing a single line of custom CSS. Tools like Tailwind UI, Headless UI, and DaisyUI further simplify component development.",
    author: "Daniel Lee",
    img: "https://images.unsplash.com/photo-1600585154340-be6161a56a0c",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 7,
    title: "A Deep Dive into JavaScript Promises",
    content: "Promises in JavaScript represent the eventual completion or failure of an asynchronous operation and its resulting value. They are a more powerful alternative to callbacks and are used extensively in modern JavaScript applications. A Promise has three states: pending, fulfilled, and rejected. When you create a new Promise using `new Promise((resolve, reject) => {})`, you provide the logic that will eventually either resolve or reject. Then you use `.then()` to handle fulfillment and `.catch()` for errors. Promises allow chaining, which improves readability and maintainability. Fetching data from APIs is one of the most common use cases. For example, `fetch('url').then(response => response.json()).then(data => ...)` demonstrates chaining multiple `.then()` calls. You can also use `Promise.all()` to run multiple promises in parallel and wait for all to complete. ES2017 introduced `async/await`, which is syntactic sugar over promises and makes asynchronous code look synchronous. It’s essential to handle errors using `try/catch` blocks with async/await. Understanding the event loop, microtasks, and how promises are scheduled in the JavaScript runtime helps write better async code. Promises are now a foundational part of JavaScript, used in everything from HTTP requests to animations and timers.",
    author: "Fatima Akter",
    img: "https://images.unsplash.com/photo-1516321497487-e288fb19713f",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 8,
    title: "Why You Should Learn TypeScript",
    content: "TypeScript is a superset of JavaScript that adds static typing, interfaces, and advanced tooling to improve developer productivity and code quality. It was developed by Microsoft and has seen rapid adoption in large-scale applications. One of the main benefits of TypeScript is early error detection. By specifying types for variables, functions, and props, you can catch many bugs before your code runs. TypeScript also provides better code completion, refactoring, and documentation in IDEs like VS Code. You can define interfaces and types to ensure consistent data structures. This is especially helpful in team environments, large codebases, and when consuming APIs. TypeScript compiles down to plain JavaScript, so it runs anywhere JS does. Adopting TypeScript doesn’t have to be all-or-nothing—you can incrementally migrate parts of your codebase by renaming `.js` files to `.ts` or `.tsx` and adding types where needed. Popular frameworks like Angular come with TypeScript out of the box, and React also works great with TypeScript, especially for typed props and state. Libraries like `zod` and `io-ts` can help with runtime validation when combined with TypeScript. As codebases grow, TypeScript’s benefits compound, making maintenance and onboarding easier. While the learning curve exists, especially for developers unfamiliar with typed languages, the long-term gains make it a worthwhile investment for modern web development.",
    author: "Rahul Saha",
    img: "https://images.unsplash.com/photo-1534972195531-d756b9bfa9f2",
    createdAt: new Date().toLocaleString(),
  },
  {
    id: 9,
    title: "State Management in React with Redux",
    content: "State management is crucial in React applications, especially as they scale. Redux is one of the most widely used libraries for managing global state in React. Redux introduces the concept of a single source of truth: a centralized store where all application state lives. This allows for predictable state changes using actions and reducers. Actions are plain JavaScript objects that describe what happened, and reducers are functions that take the current state and an action to return a new state. Redux uses a unidirectional data flow that makes debugging easier and state changes more traceable. To integrate Redux with React, developers use the `react-redux` package, which provides the `Provider` component to wrap the app and connect components to the store using hooks like `useSelector` and `useDispatch`. Redux Toolkit (RTK) has become the standard way to write Redux code. It simplifies setup and reduces boilerplate by introducing utilities like `createSlice`, `configureStore`, and built-in support for async logic via `createAsyncThunk`. While Redux is powerful, it may be overkill for small apps. Alternatives like Zustand, Jotai, or React's own Context API can be more lightweight. However, for complex applications with deeply nested components, shared state, and side effects, Redux remains a strong solution. Understanding how and when to use Redux ensures better scalability and maintainability.",
    author: "Ayesha Hasan",
    img: "https://images.unsplash.com/photo-1593720219276-0b1eacd0aef4",
    createdAt: new Date().toLocaleString(),
  }
];

export default blogs;